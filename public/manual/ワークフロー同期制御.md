# ワークフロー同期制御の詳細

> このドキュメントでは、Repo Observerのワークフロー実装の詳細な技術仕様を説明します。
> 基本的な使い方については [README.md](../../README.md) を参照してください。

## 概要

Repo Observerは単一のワークフロー (`repo-full-sync.yml`) で構成されており、複数のジョブが順次実行されます。セットアップや基本操作のガイドラインは `README.md` に集約しているため、本ドキュメントでは「どのジョブがいつ実行され、どの入力で制御されるのか」といった技術仕様に焦点を当てます。

## ワークフロー構成

### リポジトリ情報同期ワークフロー (`repo-full-sync.yml`)

- **ファイル**: `.github/workflows/repo-full-sync.yml`
- **実行タイミング**: 毎日 18:00 UTC（JST 3:00）+ 手動実行可能
- **実行時間**: 約8-25分（リポジトリ数による）
- **処理内容**:
  1. 依存関係をビルドしてキャッシュ（Job 1: build-and-prepare）
  2. CSV出力を実行（Job 2: export-csv）
  3. 必要に応じてIssue同期を実行（Job 3: sync-issues）
  4. 完了通知（Job 4: notify-completion）

## ジョブ実行フロー

```text
┌──────────────────────────────────┐
│ Job 1: build-and-prepare         │
│   - リポジトリチェックアウト     │
│   - ワークフローバージョン確認   │
│   - Node.jsセットアップ          │
│   - npm ci                       │
│   - TypeScript build             │
│   - Artifact保存 (dist, node_modules) │
└────────────┬─────────────────────┘
             │
             ├──────────────┬──────────────┐
             ↓              ↓              ↓
   ┌──────────────────┐         ┌──────────────────┐
   │ Job 2: export-csv│         │ Job 3: sync-issues│
   │ (常に実行)       │         │ (条件: run_issue_sync│
   │                  │         │  ≠ 'false' かつ    │
   │                  │         │  always())        │
   │ - Artifact取得   │         │                   │
   │ - CSV出力        │         │ - Artifact取得    │
   │ - Git commit     ├────────→│ - Issue同期       │
   │ - Artifact保存   │         │ - Project更新     │
   └──────────────────┘         └──────────┬────────┘
                                           │
                      ┌────────────────────┘
                      ↓
          ┌─────────────────────────┐
          │ Job 4: notify-completion│
          │ (always実行)             │
          │ - 実行結果サマリー表示   │
          └─────────────────────────┘
```

### ジョブの依存関係

| ジョブ | 依存 | 実行条件 |
|-------|------|---------|
| `build-and-prepare` | なし | 常に実行 |
| `export-csv` | `build-and-prepare` | 常に実行 |
| `sync-issues` | `build-and-prepare` + `export-csv` | `run_issue_sync` 入力が `false` 以外 かつ 先行ジョブ成功 |
| `notify-completion` | 全ジョブ | 常に実行（`always()`） |

### アーキテクチャの利点（まとめ）

- ✅ **ビルド時間の短縮**: npm install/buildを1回だけ実行
- ✅ **ビルド成果物の再利用**: Artifact経由で後続ジョブに配布
- ✅ **柔軟な実行パターン**: 手動入力でIssue同期の有無を制御可能
- ✅ **効率的なリソース活用**: 順次実行でAPI制限を回避
- ✅ **冪等性**: 何度実行しても同じ結果

### CSVファイルの配置とアップロードポリシー

- `CsvExporter` は `public/data/<ベース名>/<YYYY>/<MM>/<ベース名>-YYYY-MM-DD.csv` 形式でファイルを生成し、日付別フォルダへ自動的に振り分けます（メインCSVとサマリーCSV双方）。ビルド時に `out/data/` にコピーされ、デプロイ時に `docs/data/` に配置されます。
- `export-csv` ジョブでは `git add public/data` を実行してフォルダ全体をコミット対象にし、階層化した新規ファイルも漏れなく追跡します。
- 「最新CSVファイルを収集」ステップで `git status` から今回追加・更新された `.csv` のみを抽出し、そのパスを後続の Artifact アップロードに引き渡します。
- Artifact には抽出済みの最新CSVだけが添付されるため、過去分を毎回再アップロードする無駄がありません。

## GitHub API レート制限について

### 制限値

- **プライマリレート制限**: 5,000リクエスト/時間（認証済み）
- **セカンダリレート制限**: 短時間での大量リクエストに対する制限
- **GraphQL API**: 5,000ポイント/時間

### 実装済みの対策

#### 1. 自動リトライ機能

セカンダリレート制限エラー発生時、スクリプトが自動的に待機してリトライします：

- **初期待機時間**: 60秒（1分）
- **リトライ回数**: 最大6回（合計7回試行）
- **指数バックオフ**: 1分 → 2分 → 4分 → 8分 → 16分 → 32分 → 60分（上限1時間）

```typescript
// 例: セカンダリレート制限エラー時の動作
⚠️ セカンダリレート制限に達しました。1.0分（60000ms）待機してリトライします... (1/7)
⚠️ セカンダリレート制限に達しました。2.0分（120000ms）待機してリトライします... (2/7)
...
⚠️ セカンダリレート制限に達しました。60.0分（3600000ms）待機してリトライします... (7/7)
```

#### 2. API呼び出し間の待機時間

- **リポジトリ処理間**: 3秒
- **Issueキャッシュページ間**: 2秒
- **その他のAPI呼び出し**: 適宜調整

#### 3. Issueキャッシュ機能

既存Issueを事前にキャッシュすることで、検索APIの呼び出し回数を削減：

```typescript
// 全Issueを一度にキャッシュ（リスト取得APIのみ使用）
await cacheExistingIssues(owner, repo);
// 以降はキャッシュから検索（APIリクエストなし）
const existingIssue = await findExistingIssue(title);
```

### ワークフローの消費量（推定）

リポジトリ数を`N`とした場合：

| 実行パターン | API呼び出し数 | 100リポジトリの場合 |
|------------|--------------|-------------------|
| 両方実行（デフォルト） | `2N + 60`    | 約260リクエスト    |
| Issue同期のみ | `2N + 50`    | 約250リクエスト    |
| CSV出力のみ | `2N + 10`    | 約210リクエスト    |

詳細なレート制限対策については [.github/scripts/repo-full-sync/README.md](../../.github/scripts/repo-full-sync/README.md) を参照してください。

## 推奨される運用方法

### 通常運用

- ✅ **自動実行に任せる**: 毎日 UTC 18:00（JST 3:00）に自動実行
- ✅ **柔軟な実行**: 手動実行時に `run_issue_sync` 入力でIssue同期をON/OFF
- ✅ **冪等性**: 何度実行しても安全（既存データは更新される）

### 初回セットアップ時

1. 依存関係をインストール: `cd scripts && npm install && npm run build`
2. 手動実行で動作確認（Actions → "リポジトリ情報同期" → "Run workflow"）
3. 以降は自動実行に任せる

### 実行パターン

| シーン | 設定 | 使用例 |
|-------|------|-------|
| **両方実行**（推奨） | デフォルト | 定期的な同期（スケジュール/手動） |
| **CSV出力のみ** | 手動実行時に `run_issue_sync=false` | データ分析用にCSVだけ欲しい |
| **Issue同期の一時停止** | 手動実行時に `run_issue_sync=false` | メンテナンス等でIssue同期を止めたい |

### ワークフロー入力パラメータ

| パラメータ | デフォルト値 | 説明 |
|-----------|-------------|------|
| `target_user` | `KenichiroArai` | 対象ユーザー名 |
| `project_number` | `15` | Project番号（未指定で連動なし） |
| `project_status_field` | `Status` | Projectのステータスフィールド名 |
| `include_private` | `true` | プライベートリポジトリを含める |
| `include_archived` | `true` | アーカイブ済みリポジトリを含める |
| `export_summary` | `true` | サマリーCSVも出力する |
| `run_issue_sync` | `true` | Issue同期ジョブを実行するかどうか |

## トラブルシューティング

### ジョブが失敗した場合

**原因**:

- ネットワークエラー
- API制限
- スクリプトエラー

**対処方法**:

1. Actions画面でログを確認
2. エラーメッセージを確認
3. 必要に応じて再実行
4. `always()`条件により、一部失敗しても後続ジョブは実行される

#### Project番号が無効な場合

- `sync-issues` ジョブで指定した `project_number` が存在しない、または対象ユーザーのProjectでない場合は **エラーとしてジョブを失敗** させ、完了通知でも失敗が確認できるようにしています。
- ログ例: `❌ Project番号 15 をユーザー KenichiroArai で取得できませんでした。Project設定を確認してください。`
- 対処手順:
  1. GitHub ProjectのURL末尾に表示される番号を確認し、正しい値を `project_number` に設定する
  2. Project連動が不要な場合は `project_number` 入力を空にするか、ワークフローファイルのデフォルト値を削除する
  3. 修正後に手動実行で動作確認を行う

### APIレート制限に達した場合

**セカンダリレート制限**:

- スクリプトが自動的にリトライします（最大6回、合計7回試行）
- 待機時間: 1分 → 2分 → 4分 → 8分 → 16分 → 32分 → 60分（指数バックオフ / 最大1時間）

**プライマリレート制限**:

1. 1時間待つ（制限がリセットされる）
2. フィルタリングオプションを使用（`include_private: false`, `include_archived: false`）
3. レート制限の状況を確認: `curl -H "Authorization: token YOUR_TOKEN" https://api.github.com/rate_limit`

### 処理時間が長すぎる場合

- リポジトリ数が多い（100以上）場合は正常
- フィルタリングで対象を絞る
- 実行頻度を調整（週1回など）

詳細なトラブルシューティングについては [.github/scripts/repo-full-sync/README.md](../../.github/scripts/repo-full-sync/README.md) を参照してください。

## カスタマイズ例

### 実行頻度の変更

週1回実行に変更する場合:

```yaml
on:
  schedule:
    - cron: "0 18 * * 0"  # 毎週日曜日 18:00 UTC
```

月1回実行に変更する場合:

```yaml
on:
  schedule:
    - cron: "0 18 1 * *"  # 毎月1日 18:00 UTC
```

### デフォルト値の変更

プライベートリポジトリを除外する場合:

```yaml
include_private:
  description: "プライベートリポジトリを含める"
  type: boolean
  required: false
  default: false  # デフォルトで除外
```

## まとめ

単一ワークフロー + ジョブ分割のアーキテクチャにより、以下を実現：

### アーキテクチャの利点

| 観点 | 説明 | 実装 |
|-----|------|------|
| **効率性** | データ取得を1回に集約 | build-and-prepareジョブで一度だけビルド |
| **一貫性** | 同じデータで全出力を生成 | Artifactで成果物を共有 |
| **柔軟性** | Issue同期の有無を入力で制御 | `run_issue_sync` パラメータ |
| **保守性** | ロジックが1箇所に集約 | TypeScriptスクリプトの共通化 |
| **信頼性** | 自動リトライでAPI制限に対応 | 指数バックオフ方式 |

### ワークフロー実行の流れ

```text
1. ビルド → 2. CSV出力 → 3. Issue同期（任意） → 4. 完了通知
```

この構成により、シンプルかつ効率的な運用が可能です。

## 関連ドキュメント

- **[README.md](../../README.md)** - プロジェクトの概要と基本的な使い方
- **[.github/scripts/repo-full-sync/README.md](../../.github/scripts/repo-full-sync/README.md)** - スクリプトの詳細仕様とローカル実行
- **[構想.md](構想.md)** - プロジェクトの構想と背景
